#!/usr/bin/env python3
# Ulas Kamaci 2018-08-27

import numpy as np
import h5py
from matplotlib import pyplot as plt
from numpy.fft import fft2, ifft2, fftshift, ifftshift
from pssi_fwd_model import *
from sse_cost import *

def tikhonov(*, source_path, psf_path, meas_path, mode = 'Circular', lam, order = 1):
    """Perform Tikhonov regularization based image reconstruction for PSSI.

    Args:
        source_path (list): List of paths (strings) to the spectral images
        psf_path (string): path to the psfarray used in the forward model
        meas_path (string): path to the measurements generated by the forward
        model
    """

    sources = np.zeros( (len(source_path),1) + np.load(source_path[0]).shape )

    for i, path in enumerate(source_path):
        sources[i,0,:,:] = np.load(path)

    fp = h5py.File(psf_path, 'r')
    psfs = fp['psfs'].value

    fm = h5py.File(meas_path, 'r')
    meas = np.expand_dims(fm['measset'][1,:,:,:], axis=1)

    assert sources.shape[0] == psfs.shape[1], "source dimension of psf and 3D image do not match"
    [p,_,aa,bb] = sources.shape
    [k,p,ss,ss] = psfs.shape
    psfs2 = np.zeros((k,p,aa,bb))

    if order is 0:
        LAM = np.ones((aa,bb))
    elif order is 1:
        difx_ker = np.zeros((aa,bb))
        dify_ker = np.zeros((aa,bb))
        difx_ker[0,0] = -1 ; difx_ker[0,1] = 1
        dify_ker[0,0] = -1 ; dify_ker[1,0] = 1
        LAM = abs(fft2(difx_ker))**2 + abs(fft2(dify_ker))**2
    elif order is 2:
        difx_ker = np.zeros((aa,bb))
        dify_ker = np.zeros((aa,bb))
        difx_ker[0,0] = 1 ; difx_ker[0,1] = -2 ; difx_ker[0,2] = 1
        dify_ker[0,0] = 1 ; dify_ker[1,0] = -2 ; difx_ker[2,0] = 1
        LAM = abs(fft2(difx_ker))**2 + abs(fft2(dify_ker))**2

    # reshape psfs
    for i in range(k):
        for j in range(p):
            psfs2[i,j,:,:] = size_equalizer(psfs[i,j,:,:], [aa,bb])

    psfdfts = fft2(ifftshift(psfs2,axes=(2,3)))
    psfdfts_h = block_herm(psfdfts)


    recon = fftshift(
    ifft2(
        block_mul(
            block_inv(block_mul(psfdfts_h,psfdfts) + lam*np.einsum('ij,kl', np.eye(p), LAM)),
            block_mul(
                fft2(ifftshift(block_herm(psfs2),axes=(2,3))) ,
                fft2(ifftshift(meas,axes=(2,3)))
            )
        )
    ), axes=(2,3)
    )

    fig, ax = plt.subplots(nrows = 1, ncols = 3)
    im0 = ax[0].imshow(sources[0,0,:,:200])
    fig.colorbar(im0, ax=ax[0])
    ax[0].set_title('Original')
    im1 = ax[1].imshow(meas[0,0,:,:200])
    fig.colorbar(im1, ax=ax[1])
    ax[1].set_title('Measurement')
    im2 = ax[2].imshow(abs(recon[0,0,:,:200]))
    fig.colorbar(im2, ax=ax[2])
    ax[2].set_title('Reconstruction\n($\lambda$={:.1e}, order={:})'.format(lam,order))

    fp.close()
    fm.close()

    return recon

def patch_extractor(image, patch_shape):
    """Create a patch matrix where each column is a vectorized patch.
    It works with both 2D and 3D patches. Patches at the boundaries are
    extrapolated as if the image is periodically replicated. This way all
    the patches have the same dimension.

    Args:
        image (ndarray): 3D matrix representing the data cube
        patch_shape (ndarray): 1D array of length 3

    Returns:
        patch_mtx (ndarray): patch matrix containing vectorized patches in its
        columns. Number of columns (patches) is equal to the number of pixels
        (or voxels) in the image.
    """

    assert len(patch_shape) == 3, 'patch_shape must have length=3'

    [aa,bb,p] = image.shape
    patch_size = 1
    for i in patch_shape:
        patch_size = patch_size * i
    patch_mtx = np.zeros((patch_size, np.size(image)))

    # periodically extend the input image
    temp = np.concatenate((image, image[:patch_shape[0] - 1,:,:]), axis = 0)
    temp = np.concatenate((temp, temp[:,:patch_shape[1] - 1,:]), axis = 1)
    temp = np.concatenate((temp, temp[:,:,:patch_shape[2] - 1]), axis = 2)
    [rows, cols, slices] = np.unravel_index(
    range(patch_size), patch_shape)
    for i in range(np.size(patch_shape)):
        patch_mtx[i,:] = np.reshape(temp[rows[i] : aa + rows[i],
        cols[i] : bb + cols[i], slices[i] : p + slices[i]], -1)

    return patch_mtx


def patch_aggregator(patch_mtx, patch_shape = None, image_shape = None):
    """Implements the adjoint of the patch extractor operator.

    Args:
        patch_mtx (ndarray): patch matrix containing vectorized patches in its
        columns. Number of columns (patches) is equal to the number of pixels
        (or voxels) in the image.
        patch_shape (ndarray): 1D array of length 3
        image_shape (ndarray): 1D array of length 3

    Returns:
        image (ndarray): 3D matrix consisting of the aggregated patches
    """
    temp = np.zeros(image_shape + patch_shape - 1)

    [rows, cols, slices] = np.unravel_index(
    range(patch_mtx.shape[0]), patch_shape)

    for i in range(patch_mtx.shape[0]):
        temp[rows[i] : image_shape[0] + rows[i],
        cols[i] : image_shape[1] + cols[i],
        slices[i] : image_shape[2]  + slices[i]] = temp[
        rows[i] : image_shape[0] + rows[i],
        cols[i] : image_shape[1] + cols[i],
        slices[i] : image_shape[2]  + slices[i]] + np.reshape(
        patch_mtx[i,:], image_shape)

    temp[:,:,:patch_shape[2] - 1] = temp[:,:,:patch_shape[2] - 1] + temp[
    :,:,image_shape[2]:]
    temp[:,:patch_shape[1] - 1,:] = temp[:,:patch_shape[1] - 1,:] + temp[
    :,image_shape[1]:,:]
    temp[:patch_shape[0] - 1,:,:] = temp[:patch_shape[0] - 1,:,:] + temp[
    image_shape[0]:,:,:]

    return temp[:image_shape[0], :image_shape[1], :image_shape[2]]

# def tldecon_p3d(*, image, psfs, meas, patch_size, transform, nu, tr_reg, maxiter, ):


# def main(*, image_file, psfs_file, meas_file, method = 'p3d', **kwargs):
